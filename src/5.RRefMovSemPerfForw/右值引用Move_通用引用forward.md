# 右值引用请用 move 通用引用请用 forward

首先你可以直接把这个当一个定律记住 那就可以跳过这章了 不过下面还会解释一下和补充一点没啥用的内容

## 重载与通用引用的比较

重载可以同时实现对左右值的操作(对应拷贝构造和移动构造) 但这种方法有几个缺点：

1 代码量增加：每个额外的参数都会使需要实现的函数重载数量成倍增加。
假设参数 n 个 那么重载函数的数量为 2^n! 这数字还挺吓人的

2 性能下降：对于某些情况，使用通用引用的单一实现可能比使用多个重载函数更高效，因为可以避免不必要的临时对象创建和析构。

3 设计可扩展性差：当函数接受[可变数量的参数]时（例如通过模板元编程或完美转发），重载方法变得非常不切实际。
例如 c++库里的智能指针系列 有一部分就是用参数包实现的 make_unique 如下

```cpp
template<class T, class... Args>                //来自C++11标准
shared_ptr<T> make_shared(Args&&... args);

template<class T, class... Args>                //来自C++14标准
unique_ptr<T> make_unique(Args&&... args);
```

当我们传入一个参数包 这参数包里可以同时包含不等数量的左值和右值 那这是单纯的函数重载就完全不行了 这就是万能引用登场的地方

## 通用引用也不能完全取代重载

就像上面说的 万能引用这么牛逼 为什么类的构造函数不全用它？
在 c++标准库中定义的类**不都**全部实现了万能引用的模板构造函数 一般来说 标准库里的类至少会实现拷贝构造函数和移动构造函数,然后通常不会实现万能引用模板构造器 因为这有可能导致意外行为或资源管理问题 标准库的设计者会仔细考虑每个类的行为 并提供适当的构造函数来满足常见的使用场景

就像是 std::vector 类中没有实现万能构造函数 因为它的目的是存储相同类型的元素 并提供对这些元素的访问和操作 因此 需要的是能明确表达元素类型和数量的构造函数 而不是一个接收任何类型的万能引用构造函数

相比之下 智能指针系列实现了万能引用的构造函数 如上
需要注意的是，尽管智能指针实现了接受万能引用的构造函数，但它们仍然提供了拷贝构造函数和移动构造函数，以确保在需要时能够正确地复制或移动智能指针对象。这些构造函数的存在使得智能指针的使用更加灵活和方便。

总之通用引用构造器也不是想用就用的 要顾及实际需求 不能一味追求性能就乱写一通
