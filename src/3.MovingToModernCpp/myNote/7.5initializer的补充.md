## 补充

[代码](../src/ex_initilizer.cpp)

```cpp
/*
一种我们常见的可变参数的使用实在模板中的可变参数包
在C++中 `...`表示可以接受可变数目的参数 在C++中称为参数包
通过利用 模板 参数包 递归 我们可以实现对不同类型 不定长度的入参处理
*/
template <typename T>
void printf_(const T &input)
{
    std::cout << input << std::endl;
}
template <typename T, typename... Args>
void printf_(const T &num, const Args &...rest)
{
    std::cout << num << std::endl;
    printf_(rest...);
}
int main()
{
    printf_("s", 2, 3, "HELLO"); // 依次输出s,2,3, HELLO
    return 0;
}
```

以上代码的执行顺序是

```cpp
void printf_(const T &num, const Args &...rest) 打印"s"
                ↓
void printf_(const T &num, const Args &...rest) 打印"2"
                ↓
void printf_(const T &num, const Args &...rest) 打印"3"
                ↓
void printf_(const T &input) 打印"HELLO"
```

而且要注意`void printf_(const T &input)`相当于 递归终点 可以这样理解

=================================

### 实际应用 1 -- 简化参数的传入

有点复杂 仔细看能看懂 先把`Part`看懂

```cpp
struct __declspec(dllexport) Part {
    // 有四个构造函数
    Part(const std::string& p_name, const std::string& p_value, const std::string& p_content_type = {})
            : name{p_name}, value{p_value},
              content_type{p_content_type}, is_file{false}, is_buffer{false} {}

    Part(const std::string& p_name, const std::int32_t& p_value, const std::string& p_content_type = {})
            : name{p_name}, value{std::to_string(p_value)},
              content_type{p_content_type}, is_file{false}, is_buffer{false} {}

    Part(const std::string& p_name, const File& file, const std::string& p_content_type = {})
            : name{p_name}, value{file.filepath},
              content_type{p_content_type}, is_file{true}, is_buffer{false} {}

    Part(const std::string& p_name, const Buffer& buffer, const std::string& p_content_type = {})
            : name{p_name}, value{buffer.filename}, content_type{p_content_type}, data{buffer.data},
              datalen{buffer.datalen}, is_file{false}, is_buffer{true} {}

    std::string name;
    std::string value;
    std::string content_type;
    Buffer::data_t data{nullptr};
    // Ignored here since libcurl reqires a long:
    // NOLINTNEXTLINE(google-runtime-int)
    long datalen{0};
    bool is_file;
    bool is_buffer;
};

好 看完之后 再来看`Multipart`
可以见到可以用Multipart内置了一个initializer_list 方便接受一堆参数

class __declspec(dllexport) Multipart {
  public:
    Multipart(const std::initializer_list<Part>& p_parts):parts(p_parts){};
    std::vector<Part> parts;
};


// 在我们实际去使用cpr发送带multipart的请求时，我们的请求消息如下：
// 这里传入了Url和一个Multipart包 里面包括了一个initializer_list 就可以直接包裹成一个包
// 那就是说 你可以这样写 这样就很便利了 写一个webPackage就完事了
cpr::Multipart webPackage{{"part-name", cpr::File{"path-to-file", "new-file-name"}}};
cpr::Response r = cpr::Post(cpr::Url{"http://www.httpbin.org/post"},webPackage);


// The uploaded file is named "path-to-file"
cpr::Response r = cpr::Post(cpr::Url{"http://www.httpbin.org/post"},
                  cpr::Multipart{{"part-name", cpr::File{"path-to-file"}}});

// The uploaded file is named "new-file-name"
cpr::Response r = cpr::Post(cpr::Url{"http://www.httpbin.org/post"},
                  cpr::Multipart{{"part-name", cpr::File{"path-to-file", "new-file-name"}}});

// The uploaded files are named "path-to-file1" and "path-to-file2"
cpr::Response r = cpr::Post(cpr::Url{"http://www.httpbin.org/post"},
                  cpr::Multipart{{"part-name", cpr::Files{"path-to-file1", "path-to-file2"}}});

// The uploaded files are named "new-file-name1" and "new-file-name2"
cpr::Response r = cpr::Post(cpr::Url{"http://www.httpbin.org/post"},
                  cpr::Multipart{{"part-name", cpr::Files{
                                       File{"path-to-file1", "new-file-name1"},
                                       File{"path-to-file2", "new-file-name2"},
                               }}});
```

[参考链接](https://zhuanlan.zhihu.com/p/639659401)

### 实际应用 2 -- `initializer_list`和参数包的冲突

第一份代码无法传入`initializer_list`
把上面的代码改造一下

```cpp
/*
一种我们常见的可变参数的使用实在模板中的可变参数包
在C++中 `...`表示可以接受可变数目的参数 在C++中称为参数包
通过利用 模板 参数包 递归 我们可以实现对不同类型 不定长度的入参处理
*/
template <typename T>
void printf_(const T &input)
{
    std::cout << input << std::endl;
}
template <typename T, typename... Args>
void printf_(const T &num, const Args &...rest)
{
    std::cout << num << std::endl;
    printf_(rest...);
}

// 加了这个重载
template <typename T>
void printf_(std::initializer_list<T> args)
{
    for (auto i : args)
    {
        cout << i << endl;
    }
}

int main()
{
    // 实验1
    // printf_("s", 2, 3, "HELLO"); // 依次输出s,2,3, HELLO

    // 实验2
    std::initializer_list<int> x{1, 2, 3, 4, 4}; // 能用了
    printf_(x);
    return 0;
}
```
