# Item7 （）与{ }的区别

## 等号`=`不一定是赋值

```cpp
Widget w1; // 默认构造函数

Weidgt w2 = w1; // 这里!不是!赋值运算 是隐式调用拷贝函数

w3 = w2; // 赋值运算 调用拷贝赋值运算符（copy operator=）
```

## 前置知识 聚合类的定义与个版本的区别

    c++11 ①所有成员都是public  ②没有类内初始化【c17后取消】  ③没有定义构造函数（但是可以写成default） ④没有基类也没有virtual函数
    c++17 可以有基类 但都要public继承 || 必须非虚继承 || 基类可以不是聚合物

c++11 的写法如下

```cpp
struct A{
    int a;
    double b;
    float c;
    A(){} = default;
}
```

## 用{ }给聚合类初始化可以简便一点

```cpp
    A{1, 1., 2.f} √
    A(1, 1. , 2.f) x 不能用圆括号
```

但如果 A 并非聚合类 那么就会报错 这时就要老老实实写 Constructor 了

## 使用{}代替()的好处 1：避免匿名对象被视为函数指针

### 小前置 c/c++可以容忍多余的括号

        如int (a),与int a等效； a = 10与 a = (10)等效

比如

```cpp
int f(double value){
    int a(int (value));
}
```

函数体内这句话可以有两种解释

- Ⅰ 由于括号是可以视为多余的 int (value) === int value 而且在 a 的初始化括号里（先认为是初始化操作） 相当于
  (int value)是在圆括号内搞了个匿名对象 该匿名对象类型为 int 初始值为 value
  则整句话视为`变量声明` 声明了个整数类型的 a 其初始值是 赋予了 value 值得一个匿名对象
  即 int (value) === int ??? (value) 其中???是匿名对象 对它使用了圆括号初始化

- Ⅱ 视为函数 其中鼠标悬浮的话会将上述解释为 `int a(int (*) value)`()
  即 int (value) === int ??? (value) 然后???被视为函数指针

```cpp
#include <iostream>
using namespace std;
int a;
int c(int(a)) {}  // 视为函数

int f(double value)
{
    int a(int(value)); // 视为变量
}

int main(int argc, char const *argv[])
{
    f(1.2);
    return 0;
}
```

解释一下 我这份补充 md 大部分参考[https://www.bilibili.com/video/BV1Gg4y1p71w/?p=7&vd_source=81a486ecde68fedb0b0b8563ba5a46cc]
视频里 a 会解释为函数声明 但是在我的编译器和各版本 c++中都发现 a 是变量 额 我也说不清楚 反正以后不要这样声明就是了
但是这种写法依旧可能存在 例如

```cpp
struct Timer{
};

struct TimerKeeper
{
    TimerKeeper(Timer T()){}; // Constructor
};

int main(int argc, char const *argv[])
{
    Timer(); // 匿名对象
    TimerKeeper tk(Timer()); // 会被编译器解析为TimerKeeper tk(Timer (*)())
    return 0;
}
```

如上
本意是想搞一个 Timer 的临时对象 给 Timer 用圆括号()初始化
初始化+无等号来构造临时对象 然后把 tk 声明为变量

但事与违源 编译器会把它解释成一个`函数声明` => TimerKeeper tk(Timer (\*)()) 这里的 Timer()视为函数并降级为函数指针

解决方法为用`{ }`来初始化 就能完全避免歧义 如 TimerKeeper tk{Timer()}; 此时 tk 就是变量了

## 好处 2：不可拷贝对象可以使用{}或()初始化 但是不能用`=`

另一方面，不可拷贝的对象（例如`std::atomic`——见[Item40](../7.TheConcurrencyAPI/item40.md)）可以使用花括号初始化或者圆括号初始化，但是不能使用"="初始化：

```cpp
std::atomic<int> ai1{ 0 };      //没问题
std::atomic<int> ai2(0);        //没问题
std::atomic<int> ai3 = 0;       //错误！
```

## 好处 3：不允许隐式**缩窄转换**

除非使用显示转换`static_cast`

```cpp
double x, y, z;

int sum1{ x + y + z };          //错误！double的和可能不能表示为int
```

## 对 stl 容器使用{}的注意事项

另外补充一点：`array` 和原生数组一样 都是静态数组(更推荐使用`array`)
而`vector`是动态数组

```cpp
// 简单类型 原始数组
int a1[3] = {1,2,3};
int a2[3]{1,2,3};

// 简单类型 std::array
std::array<int, 3> a3 = {1,2,3};
std::array<int, 3> a4{1,2,3};

// 复杂类型 原生数组
struct A{int x, int y};
A a5[3] = {{1,2}, {3,4}, {5,6}};
A a6[3] = {1,2,3,4,5,6}; // 虽然很反直觉也不直观 但是编译器会把a6优化为a5 编译器 很神奇罢

// 复杂类型 std::array
std::array<A, 3> a7{{1,2}, {3,4}, {5,6}}; // X 会报错 下面解释
std::array<A, 3> a8 = {1,2, 3,4, 5,6}; // X 会报错 下面解释
std::array<A, 3> a9{{{1,2}, {3,4}, {5,6}}}; // 多套一层花括号才行
```

其中 a7 a8 都是等效 而且都会报错

### 原因：array 是聚合类 聚合类可以用`{ }`来初始化

而且为了保证 array 和原生数组速度一致 会在 array 内部放一个原生数组 再加上一堆函数来保证 array 的安全性
array 的实现类似于

```cpp
template<typename T, size_t N>
class array{
    T arr[N];
};
```

a7/a8 的写法相当于 令`T arr[N] = {1,2}, {3,4}, {5,6} ` 这一看就语法错误了
所以才要在外面多套一层花括号{ } 才会得到`T arr[N] = {{1,2}, {3,4}, {5,6}};`

当然也可以写成 a5 a6 那种形式 当`只有一个List`时 编译器也能帮你解析成功
`std::array<A, 3> a10{1,2,3,4,5,6};`

## 用户自定义容器时 要小心 initializer_list 抢变量

### 小前置 `{ }`**不允许**缩窄转换

但是非要转换 可以用 static_cast()

### 编译器会优先选择 initilizer_list

```cpp
class A{
    A(int ,int){}; // Ⅰ
    A(int ,float){}; // Ⅱ
    A(initializer_list<int>){}; // Ⅲ
}

A a(1,2); // 调用Ⅰ
A b{1,2}; // 调用Ⅱ 有可能事与违源
A c(1, 2.f); // 调用Ⅲ
A d{1, 2.f}; // 会【强制】调用Ⅱ  就算会报错 就算Ⅲ才是最匹配的 因为float可以隐式转变为整型
```

### 万不得已编译器才会放弃 initializer_list

```cpp
class A{
    ... // 续上
    A(int, String){}; // Ⅳ
}

A a{1, "ghd"}; // 虽然用了花括号 但是由于String不能转变为整型 让编译器不得不选了Ⅳ
```

## ！！！空的{ }, 不会调用 initializer_list 构造 而是无参构造

```cpp
class A
{
public:
    A() { cout << "A()" << endl; }; // Ⅰ
    A(initializer_list<int> a) { cout << "initializer_list<int>" << endl; }; // Ⅱ
    A(int a) { cout << "A(int)" << endl; }; // Ⅲ
};
int main(int argc, char const *argv[])
{
    A a{}; // 调用Ⅰ
    A b{1}; // 调用Ⅱ
    A c({}); // 调用Ⅱ 但是list长度为0
    A d{{}}; // 调用Ⅱ 但是list长度为1

    A e(); // 被解析成一个 函数声明

    return 0;
}

```

## 注意{}和()在 std::vector 的区别

```cpp
std::vector<int> v1(10, 20);    //使用非std::initializer_list构造函数
                                //创建一个包含10个元素的std::vector，
                                //所有的元素的值都是20

std::vector<int> v2{10, 20};    //使用std::initializer_list构造函数
                                //创建包含两个元素的std::vector，
                                //元素的值为10和20
```

## 应该选择()还是{}??

学完以上就得到两个重要结论

1. 作为一个类库作者
   如果你选择在一堆的重载函数里使用一个/多个`std::initializer_list`,需要考虑到不管用户使用圆括号()或者花括号{} 都不应该对初始化有什么影响
   即 了解了上述`std::vector`的缺点之后 以后设计类就需要避免诸如此类的问题

   换个角度即如果一个类里没有`std::initializer_list`构造函数时 然后你添加一个后 可能就让`initializer_list`覆盖了其他的重载函数
   即如果要加入`std::initializer_list`构造函数 _请三思_

2. 作为一个类库使用者
   必须认真的在{}和()之间选择一个来创建对象。大部分开发者都使用*其中一种*，只有当这种不行时采用另外一种
   默认使用{}优点为：适用面光 禁止变窄转换 免疫 C++最烦人的解析
   但是例如给`std::vector`传入容器大小`Size`和初始值时就必须要用()
   关于()和{}初始化哪种更好没有达成一致 所以建议选择一种并坚持使用它

3. 对于模板的作者 {}和()创建对象就更麻烦了 通常不知道哪个会被使用。
   [对于 initializer_list 的补充](./7.5initializer的补充.md)

   假设有以下代码

   ```cpp
   template<typename T,            //要创建的对象类型
         typename... Ts>        //要使用的实参的类型
   void doSomeWork(Ts&&... params)
   {
        create local T object from params...
        …
        // 示例代码 两个分支
        // 1.使用圆括号
        T localObject(std::forward<Ts>(params)...);
        // 则传入的std::vector就会包含10个元素

        // 2.使用花括号
        T localObject{std::forward<Ts>(params)...};//使用花括号
        // 则传入的std::vector就会包括2个元素
   }

    // 调用
   std::vector<int> v;
   …
   doSomeWork<std::vector<int>>(10, 20);
   ```

   这样的错误也不能说是调用者的错 哪个是正确的？`doSomeWork`的作者不知道，只有调用者知道。

这正是标准库`std::make_unique`和`std::make_shared`（参见[Item21](../4.SmartPointers/item21.md)）面对的问题。它们的解决方案是使用圆括号，并被记录在文档中作为接口的一部分。
（注：更灵活的设计——允许调用者决定从模板来的函数应该使用圆括号还是花括号——是有可能的。详情参见[Andrzej’s C++ blog](http://akrzemi1.wordpress.com/)在 2013 年 6 月 5 日的文章，“[Intuitive interface — Part I.](http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/)”）

**请记住：**

- 花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于 C++最令人头疼的解析有天生的免疫性
- 在构造函数重载决议中，编译器会尽最大努力将括号初始化与`std::initializer_list`参数匹配，即便其他构造函数看起来是更好的选择
- 对于数值类型的`std::vector`来说使用花括号初始化和圆括号初始化会造成巨大的不同
- 在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战。
